using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System;
using UnityEngine.Rendering;

namespace Veridian.Imposters
{
    // This gives us a clean, readable way to refer to the current pipeline.
    public enum RenderPipelineType { BuiltIn, URP, HDRP, Unknown }

    /// <summary>
    /// This class defines the editor window for the Advanced Billboard Creator tool.
    /// It handles the user interface (UI), manages settings, and orchestrates the
    /// entire billboard generation process by coordinating with various service classes.
    /// </summary>
    public class BillboardSnapshotWindow : EditorWindow
    {
        // --- SETTINGS & SERVICES ---
        // A reference to the ScriptableObject that holds all the user-configurable settings for billboard generation.
        // This allows for saving and reusing presets.
        private BillboardSettings activeSettings;
        // A reference to the service responsible for capturing textures from the source object.
        private TextureGeneratorService textureService;
        // A reference to the service responsible for constructing the final billboard mesh.
        private BillboardMeshService meshService;

        // --- RENDER PIPELINE SHADER REFERENCES ---
        // These fields hold references to the shaders required for capturing world-space normals.
        // The correct shader is chosen at runtime based on the active Render Pipeline (Built-in, URP, or HDRP).
        private Shader normalCaptureShaderBuiltIn;
        private Shader normalCaptureShaderURP;
        private Shader normalCaptureShaderHDRP;

        // --- UI & STATE MANAGEMENT ---
        // The source GameObject to be converted into a billboard. This can be a prefab from the project or an object in the scene.
        private GameObject sourcePrefab;
        // The current position of the scroll view in the editor window, allowing all options to be visible even in a small window.
        private Vector2 scrollPosition;
        // A boolean to control the visibility of the "Horizontal Cross-Section Quads" foldout in the UI.
        private bool showHorizontalSectionsUI = true;
        // Stores the path to the folder where the last set of assets was generated. Used by the "Delete Last Generated Assets" button.
        private string lastGeneratedAssetPath;

        // --- CACHED DATA ---
        // This holds all the data generated by the TextureGeneratorService (Step 1), including texture snapshots and atlas information.
        // It's cached to allow Step 2 (mesh creation) to be run without regenerating textures.
        private GeneratedTextureData lastGeneratedSnapshotData;
        // The calculated bounds of the source object, normalized to its pivot. This is cached after calculation to be passed to the mesh service.
        private Bounds lastSourceObjectNormalizedBounds;
        // The calculated vertical offset (the world-space Y position of the object's lowest point). This is used to position the billboard correctly at the object's base.
        private float lastVerticalOffset;


        // --- CONSTANTS ---
        // These arrays define the user-facing options and their corresponding integer values for UI popups (dropdowns).
        // This separates the user-friendly text from the underlying data used by the tool.

        // Defines the display text for the resolution dropdown.
        private readonly string[] resolutionOptions = { "128", "256", "512", "1024", "2048" };
        // Defines the actual integer values corresponding to the resolutionOptions.
        private readonly int[] resolutionValues = { 128, 256, 512, 1024, 2048 };
        // Defines the display text for the number of snapshots dropdown.
        private readonly string[] numSnapshotsDisplayOptions = { "4 Directions", "6 Directions", "8 Directions", "12 Directions", "16 Directions" };
        // Defines the actual integer values corresponding to the numSnapshotsDisplayOptions.
        private readonly int[] numSnapshotsValues = { 4, 6, 8, 12, 16 };
        // Defines the display text for the supersampling dropdown.
        private readonly string[] supersamplingOptions = { "1x (None)", "2x", "4x" };
        // Defines the actual integer values corresponding to the supersamplingOptions.
        private readonly int[] supersamplingValues = { 1, 2, 4 };
        // A fixed value defining the vertical size of the "shoulder" area for the Octagon profile shape.
        private const float OCTAGON_SHOULDER_VERTICAL_FRACTION_CONST = 0.1f;


        /// <summary>
        /// Creates the menu item in the Unity Editor to open the tool's window.
        /// The path "Tools/..." determines its location in the top menu bar.
        /// </summary>
        [MenuItem("Tools/VeridianImposters", false, 2003)]
        public static void ShowWindow()
        {
            // GetWindow is the standard way to create and show an editor window.
            GetWindow<BillboardSnapshotWindow>("VeridianImposters");
        }

        /// <summary>
        /// Called when the editor window is enabled or created.
        /// Use this for initialization tasks.
        /// </summary>
        void OnEnable()
        {
            // Instantiate the service classes that contain the core logic for generation.
            textureService = new TextureGeneratorService();
            meshService = new BillboardMeshService();

            // Find and cache the necessary shaders. Shader.Find can be slow, so it's best to do it once on enable.
            normalCaptureShaderBuiltIn = Shader.Find("Hidden/AdvancedBillboardCreator/NormalCapture_Builtin");
            normalCaptureShaderURP = Shader.Find("Hidden/AdvancedBillboardCreator/NormalCapture_URP");
            normalCaptureShaderHDRP = Shader.Find("Hidden/AdvancedBillboardCreator/NormalCapture_HDRP");

            // Log warnings if any of the required shaders are missing, which helps in troubleshooting.
            if (normalCaptureShaderBuiltIn == null) Debug.LogWarning("Built-in Normal Capture shader not found.");
            if (normalCaptureShaderURP == null) Debug.LogWarning("URP Normal Capture shader not found.");
            if (normalCaptureShaderHDRP == null) Debug.LogWarning("HDRP Normal Capture shader not found.");
        }

        /// <summary>
        /// Called when the editor window is disabled or closed.
        /// Use this for cleanup to prevent memory leaks.
        /// </summary>
        void OnDisable()
        {
            // Clean up any temporary data, especially textures, that might be held in memory.
            ClearPreviewData();
        }

        /// <summary>
        /// Clears any cached snapshot data, destroying temporary texture objects to free up memory.
        /// </summary>
        void ClearPreviewData()
        {
            // The Clear() method within GeneratedTextureData handles destroying the Texture2D objects.
            lastGeneratedSnapshotData?.Clear();
            lastGeneratedSnapshotData = null;
        }

        /// <summary>
        /// Called by Unity to draw the editor window's GUI. This method is called multiple times per second.
        /// </summary>
        void OnGUI()
        {
            // Begin a scrollable area. This allows the UI to fit even if the window is small.
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
            GUILayout.Label("Veridian Imposter Creator (ScriptableObject Version)", EditorStyles.boldLabel);
            EditorGUILayout.Space();

            // --- Configuration Asset Management ---
            // This section handles the assignment of the BillboardSettings ScriptableObject.
            EditorGUILayout.LabelField("Configuration", EditorStyles.boldLabel);
            activeSettings = (BillboardSettings)EditorGUILayout.ObjectField("Settings Asset", activeSettings, typeof(BillboardSettings), false);
            if (GUILayout.Button("Create and Assign New Settings Asset")) { CreateNewSettingsAsset(); }
            EditorGUILayout.Space();

            // The rest of the UI is disabled until a settings asset is assigned.
            if (activeSettings == null)
            {
                EditorGUILayout.HelpBox("Please assign or create a Billboard Settings asset to continue.", MessageType.Warning);
                EditorGUILayout.EndScrollView(); // End the scroll view here if there's nothing else to draw.
                return;
            }

            // --- Main UI Drawing and Change Detection ---
            // Begin a check to see if any GUI control's value has changed.
            EditorGUI.BeginChangeCheck();

            // Call the main method to draw all the detailed controls for the tool.
            DrawFullUI();

            // If any control was changed during the DrawFullUI call...
            if (EditorGUI.EndChangeCheck())
            {
                // Mark the settings asset as "dirty". This tells Unity that it has unsaved changes.
                EditorUtility.SetDirty(activeSettings);
                // Save the changes to disk. This makes the settings persistent.
                AssetDatabase.SaveAssets();
            }

            // End the scrollable area.
            EditorGUILayout.EndScrollView();
        }

        /// <summary>
        /// This is Step 1 of the billboard creation process. It orchestrates the generation of all necessary texture data.
        /// It calculates object bounds, sets up parameters, and calls the TextureGeneratorService to perform the actual captures.
        /// The resulting data (textures, dimensions, etc.) is cached in 'lastGeneratedSnapshotData' for Step 2.
        /// </summary>
        void GenerateSnapshotData()
        {
            // --- 1. Initial Validation ---
            // Ensure that the user has assigned a source prefab in the UI.
            if (sourcePrefab == null)
            {
                EditorUtility.DisplayDialog("Error", "Source Prefab must be assigned.", "OK");
                return; // Abort if no source.
            }
            // If normal map generation is enabled, ensure that the appropriate shader for the current render pipeline has been found.
            if (activeSettings.GenerateNormalMap && GetActiveNormalCaptureShader() == null)
            {
                EditorUtility.DisplayDialog("Error", "Normal Capture Shader for the active render pipeline is missing. Please ensure the correct shader package is installed.", "OK");
                return; // Abort if shader is missing.
            }

            // Clear any data from a previous run to ensure a fresh start.
            ClearPreviewData();

            // --- 2. Bounds Calculation ---
            // This is a critical step to determine the size and position of the object for the snapshot camera.
            // It's wrapped in a try/catch/finally block to ensure cleanup happens even if errors occur.
            GameObject tempInstanceForBounds = null;
            try
            {
                // Instantiate a temporary, non-normalized version of the prefab to get its bounds in world space.
                // This is necessary to correctly calculate the 'lastVerticalOffset'.
                tempInstanceForBounds = PrepareInstanceForSnapshot(sourcePrefab, activeSettings.SourceLODIndex, false);
                if (tempInstanceForBounds != null)
                {
                    // Calculate the combined bounds of all renderers in the temporary instance.
                    Bounds worldBounds = CalculateObjectBounds(tempInstanceForBounds);

                    // Check for a "BillboardAnchor" child object. If it exists, use its X/Z position
                    // as the horizontal center for the billboard, which is often more accurate than the geometric center.
                    Transform anchor = tempInstanceForBounds.transform.Find("BillboardAnchor");
                    if (anchor != null)
                    {
                        Vector3 anchorPosition = anchor.position;
                        // Create a new center point using the anchor's X/Z and the original bounds' Y.
                        Vector3 newCenter = new Vector3(anchorPosition.x, worldBounds.center.y, anchorPosition.z);
                        worldBounds.center = newCenter;
                        Debug.Log($"Anchor found for '{sourcePrefab.name}'. Correcting XZ center while preserving original Y center.");
                    }
                    // Cache the lowest point of the object on the Y-axis. This is used to position the final billboard correctly on the ground.
                    lastVerticalOffset = worldBounds.min.y;

                    // Now, create another instance but with its transform normalized (reset to origin, no rotation/scale).
                    // This is the instance that will be used for the actual snapshots.
                    GameObject normalizedInstance = PrepareInstanceForSnapshot(sourcePrefab, activeSettings.SourceLODIndex, true);
                    Bounds normalizedBounds = CalculateObjectBounds(normalizedInstance);
                    Transform normalizedAnchor = normalizedInstance.transform.Find("BillboardAnchor");
                    if (normalizedAnchor != null)
                    {
                        // If an anchor exists, adjust the center of the normalized bounds as well.
                        Vector3 anchorLocalPos = normalizedAnchor.localPosition;
                        Vector3 newNormalizedCenter = new Vector3(anchorLocalPos.x, normalizedBounds.center.y, anchorLocalPos.z);
                        normalizedBounds.center = newNormalizedCenter;
                    }
                    // Cache the final, adjusted normalized bounds. This is what the texture and mesh services will use.
                    lastSourceObjectNormalizedBounds = normalizedBounds;
                    DestroyImmediate(normalizedInstance); // Clean up the normalized instance.
                }
                else
                {
                    throw new System.Exception("Failed to instantiate and prepare prefab for bounds calculation.");
                }
            }
            catch (System.Exception e)
            {
                // If any error occurs during bounds calculation, log it and set fallback values.
                Debug.LogError($"Bounds calculation error: {e.Message}");
                lastSourceObjectNormalizedBounds = new Bounds(Vector3.zero, Vector3.one * 0.1f);
                lastVerticalOffset = 0;
            }
            finally
            {
                // No matter what happens, ensure the temporary instance used for bounds calculation is destroyed.
                if (tempInstanceForBounds != null) DestroyImmediate(tempInstanceForBounds);
            }

            // --- 3. Package Settings for Texture Service ---
            // Create a data transfer object (DTO) to pass all the necessary settings from the UI
            // to the TextureGeneratorService. This keeps the service's method signature clean.
            TextureGeneratorSettings texSettings = new TextureGeneratorSettings
            {
                TargetObject = this.sourcePrefab,
                Views = this.numSnapshotsValues[activeSettings.NumSnapshotsIndex],
                AtlasHeightResolution = this.resolutionValues[activeSettings.ResolutionIndex],
                SupersamplingFactor = this.supersamplingValues[activeSettings.SupersamplingIndex],
                EnableEdgePadding = activeSettings.EnableEdgePadding,
                EdgePaddingIterations = activeSettings.EdgePaddingIterations,
                AlphaProcessingClipThreshold = activeSettings.AlphaProcessingClipThreshold,
                GenerateNormalMap = activeSettings.GenerateNormalMap,
                NormalCaptureShader = GetActiveNormalCaptureShader(),
                EnableHorizontalCap = (activeSettings.HorizontalCrossSectionDefs != null && activeSettings.HorizontalCrossSectionDefs.Count > 0),
                OptimizeTexturesForFrontFace = (activeSettings.RenderMode == BillboardRenderMode.Efficient),
                SnapshotLayerIndex = activeSettings.SnapshotLayerIndex,
                Lighting = new SnapshotLightingSettings
                {
                    AmbientLightMultiplier = activeSettings.SnapshotAmbientLightMultiplier,
                    AmbientIntensity = activeSettings.SnapshotAmbientIntensity,
                    KeyLightIntensity = activeSettings.SnapshotKeyLightIntensity,
                    KeyLightRotation = activeSettings.SnapshotKeyLightRotation
                },
                Camera = new SnapshotCameraParameters
                {
                    CaptureDistanceOffset = activeSettings.CameraCaptureDistanceOffset,
                    FramePadding = activeSettings.FramePadding
                }
            };

            // --- 4. Execute Texture Generation ---
            // Call the texture service, passing in the settings DTO, the LOD index, and the pre-calculated bounds.
            // The service will return a GeneratedTextureData object containing all the new textures and metadata.
            RenderPipelineType pipelineType = GetActivePipeline();
            this.lastGeneratedSnapshotData = textureService.GenerateAtlasAndSnapshots(texSettings, activeSettings.SourceLODIndex, lastSourceObjectNormalizedBounds, pipelineType);

            // --- 5. Final Feedback ---
            // Check if the generation was successful by seeing if an albedo texture was created.
            if (this.lastGeneratedSnapshotData?.AlbedoAtlasTexture != null)
            {
                // Inform the user of success. The UI will now update to show the texture previews.
                EditorUtility.DisplayDialog("Success", "Snapshot atlas data generated!", "OK");
            }
            else
            {
                // Inform the user of failure.
                EditorUtility.DisplayDialog("Error", "Texture data generation failed. Check the console for details.", "OK");
            }
        }

        /// <summary>
        /// Takes the generated snapshot data and uses it to create and save all the final billboard assets
        /// (mesh, material, textures, and the final prefab). This is the second main step in the workflow.
        /// </summary>
        void CreateBillboardAssetsFromGeneratedData()
        {
            // --- 1. VALIDATION ---
            // Ensure that the texture data from Step 1 exists and a source prefab is still assigned.
            // If not, abort the process and inform the user.
            if (lastGeneratedSnapshotData == null || sourcePrefab == null)
            {
                EditorUtility.DisplayDialog("Error", "Missing generated texture data or source prefab. Please complete Step 1 first.", "OK");
                return;
            }

            // --- 2. PREPARATION AND PATHS ---
            // Store the source prefab's original transform properties. These will be applied to the
            // final billboard prefab to ensure it has the same rotation and scale as the original.
            Quaternion sourcePrefabRotation = sourcePrefab.transform.rotation;
            Vector3 sourcePrefabScale = sourcePrefab.transform.localScale;

            // Determine a base name for the output assets. Use the user-defined prefix if available; otherwise, default to the source object's name.
            string sourcePrefabName = sourcePrefab.name;
            // Try to get the directory of the source prefab to save the new assets next to it. Default to the root "Assets" folder if the path is not found.
            string initialDirectory = AssetDatabase.GetAssetPath(sourcePrefab);
            initialDirectory = !string.IsNullOrEmpty(initialDirectory) ? Path.GetDirectoryName(initialDirectory) : "Assets";
            string userPrefix = string.IsNullOrEmpty(activeSettings.UserDefinedBaseName) ? sourcePrefabName : activeSettings.UserDefinedBaseName;

            // Construct a descriptive folder name based on the generation settings.
            // This helps organize different billboard variations of the same object.
            string capSuffix = (activeSettings.HorizontalCrossSectionDefs != null && activeSettings.HorizontalCrossSectionDefs.Count > 0) ? $"_{activeSettings.HorizontalCrossSectionDefs.Count}HQuad" : "";
            string renderModeSuffix = $"_{activeSettings.RenderMode}";
            string lodSuffix = activeSettings.EnableLODCreation ? "_LODBillboard" : "_Billboard";
            string dynamicFolderName = $"{userPrefix}_{lastGeneratedSnapshotData.Views}Dir_{activeSettings.ProfileShape}{capSuffix}{renderModeSuffix}{lodSuffix}_Assets";
            string targetDirectoryPath = Path.Combine(initialDirectory, dynamicFolderName);

            // Create the target directory if it doesn't already exist.
            if (!Directory.Exists(Path.GetFullPath(targetDirectoryPath)))
            {
                try
                {
                    Directory.CreateDirectory(targetDirectoryPath);
                    AssetDatabase.Refresh(); // Ensure Unity's asset database recognizes the new folder.
                }
                catch (Exception e)
                {
                    Debug.LogError($"Could not create directory {targetDirectoryPath}: {e.Message}");
                    return;
                }
            }
            // Store the path for the "Delete Last Generated Assets" functionality.
            lastGeneratedAssetPath = targetDirectoryPath;
            // Construct a base name for the individual asset files within the folder.
            string assetBaseName = $"{userPrefix}_{lastGeneratedSnapshotData.Views}Dir_{activeSettings.ProfileShape}{capSuffix}{renderModeSuffix}";

            // Declare variables to hold references to the created assets and their paths.
            // This is crucial for cleanup in the `catch` block if any part of the process fails.
            Texture2D savedAlbedo = null;
            Texture2D savedNormal = null;
            Material savedMat = null;
            Mesh savedMesh = null;
            string albPath = "", nrmPath = "", matPath = "", meshPathVal = "";

            try
            {
                // --- 3. SAVE TEXTURE ASSETS ---
                // Save Albedo Texture Atlas
                byte[] albBytes = lastGeneratedSnapshotData.AlbedoAtlasTexture.EncodeToPNG();
                albPath = AssetDatabase.GenerateUniqueAssetPath(Path.Combine(targetDirectoryPath, assetBaseName + "_AlbedoAtlas.png"));
                File.WriteAllBytes(Path.GetFullPath(albPath), albBytes);
                AssetDatabase.ImportAsset(albPath, ImportAssetOptions.ForceUpdate); // Tell Unity to import the new file.
                // Configure the texture importer settings for the albedo map.
                TextureImporter albImp = AssetImporter.GetAtPath(albPath) as TextureImporter;
                if (albImp != null)
                {
                    albImp.alphaIsTransparency = true;
                    albImp.alphaSource = TextureImporterAlphaSource.FromInput;
                    albImp.wrapMode = TextureWrapMode.Clamp; // Clamp prevents edge artifacts.
                    albImp.sRGBTexture = true; // Albedo maps are in sRGB color space.
                    albImp.SaveAndReimport();
                }
                savedAlbedo = AssetDatabase.LoadAssetAtPath<Texture2D>(albPath);

                // Save Normal Texture Atlas (if generated)
                if (lastGeneratedSnapshotData.NormalAtlasTexture != null && activeSettings.GenerateNormalMap)
                {
                    byte[] nrmBytes = lastGeneratedSnapshotData.NormalAtlasTexture.EncodeToPNG();
                    nrmPath = AssetDatabase.GenerateUniqueAssetPath(Path.Combine(targetDirectoryPath, assetBaseName + "_NormalAtlas.png"));
                    File.WriteAllBytes(Path.GetFullPath(nrmPath), nrmBytes);
                    AssetDatabase.ImportAsset(nrmPath, ImportAssetOptions.ForceUpdate);
                    // Configure the texture importer settings for the normal map.
                    TextureImporter nrmImp = AssetImporter.GetAtPath(nrmPath) as TextureImporter;
                    if (nrmImp != null)
                    {
                        nrmImp.textureType = TextureImporterType.NormalMap; // This is crucial for the engine to use it correctly.
                        nrmImp.wrapMode = TextureWrapMode.Clamp;
                        nrmImp.sRGBTexture = false; // Normal maps are linear.
                        nrmImp.SaveAndReimport();
                    }
                    savedNormal = AssetDatabase.LoadAssetAtPath<Texture2D>(nrmPath);
                }
                if (savedAlbedo == null) throw new Exception("Failed to save or load the albedo atlas texture.");

                // --- 4. CREATE AND SAVE MATERIAL ---
                var matInfo = GetPipelineMaterialInfo();
                Shader bbShader = Shader.Find(matInfo.shaderName);
                if (bbShader == null) throw new Exception($"Could not find shader: '{matInfo.shaderName}'. Make sure the pipeline is supported and the shader is included in the build.");

                matPath = AssetDatabase.GenerateUniqueAssetPath(Path.Combine(targetDirectoryPath, assetBaseName + "_Material.mat"));
                savedMat = new Material(bbShader) { name = Path.GetFileNameWithoutExtension(matPath) };
                savedMat.SetTexture(matInfo.albedoProperty, savedAlbedo);
                if (savedNormal != null)
                {
                    savedMat.SetTexture(matInfo.normalProperty, savedNormal);
                    savedMat.EnableKeyword(matInfo.normalKeyword); // Enable the normal map feature in the shader.
                }
                else
                {
                    savedMat.DisableKeyword(matInfo.normalKeyword);
                }
                SetMaterialProperties(savedMat); // Apply other properties like alpha clipping and smoothness.
                AssetDatabase.CreateAsset(savedMat, matPath);
                savedMat = AssetDatabase.LoadAssetAtPath<Material>(matPath); // Load the asset back to ensure it's valid.
                if (savedMat == null) throw new Exception("Material creation failed.");

                // --- 5. GENERATE AND SAVE MESH ---
                // Package all necessary parameters for the mesh generation service.
                MeshGenerationSettings meshGenParams = new MeshGenerationSettings
                {
                    SourceObjectNormalizedBounds = this.lastSourceObjectNormalizedBounds,
                    VerticalOffset = this.lastVerticalOffset,
                    SourcePrefabOriginalScale = sourcePrefabScale,
                    ProfileShape = activeSettings.ProfileShape,
                    Views = lastGeneratedSnapshotData.Views,
                    OctagonParams = (activeSettings.ProfileShape == BillboardProfile.Octagon) ? new OctagonShapeParameters { BottomWidthFraction = activeSettings.OctagonBottomWidthFraction, TopWidthFraction = activeSettings.OctagonTopWidthFraction, MaxWidthCenterYFraction = activeSettings.OctagonMaxWidthCenterYFraction, ShoulderVerticalFraction = OCTAGON_SHOULDER_VERTICAL_FRACTION_CONST } : default,
                    HorizontalCrossSections = new List<HorizontalCrossSectionDefinition>(activeSettings.HorizontalCrossSectionDefs ?? new List<HorizontalCrossSectionDefinition>()),
                    RenderMode = activeSettings.RenderMode
                };
                savedMesh = meshService.GenerateBillboardMeshData(lastGeneratedSnapshotData, meshGenParams);
                if (savedMesh == null) throw new Exception("Mesh generation failed. Check console for errors from the mesh service.");
                meshPathVal = AssetDatabase.GenerateUniqueAssetPath(Path.Combine(targetDirectoryPath, assetBaseName + "_Mesh.asset"));
                AssetDatabase.CreateAsset(savedMesh, meshPathVal);

                // --- 6. ASSEMBLE FINAL PREFAB ---
                // Create a new GameObject to hold the billboard's mesh renderer and filter.
                GameObject bbRendererGO = new GameObject(sourcePrefabName + "_Billboard_Renderer");
                bbRendererGO.AddComponent<MeshFilter>().sharedMesh = savedMesh;
                bbRendererGO.AddComponent<MeshRenderer>().sharedMaterial = savedMat;

                // Apply the XZ scale factor to make the billboard appear fuller without vertical stretching.
                bbRendererGO.transform.localScale = new Vector3(activeSettings.XZScaleFactor, 1f, activeSettings.XZScaleFactor);

                GameObject rootObjectToSave;
                // If creating an LOD group, the process is different from creating a standalone billboard.
                if (activeSettings.EnableLODCreation)
                {
                    // The manual vertical offset is applied to the renderer object's LOCAL position,
                    // as it will be a child of the new LOD group root.
                    bbRendererGO.transform.localPosition = new Vector3(0, activeSettings.ManualVerticalOffset, 0);
                    // The CreateLODPrefab helper method will construct the new prefab root with the LODGroup component.
                    rootObjectToSave = CreateLODPrefab(bbRendererGO, assetBaseName);
                }
                else
                {
                    // If not creating an LOD group, the renderer object itself is the root of the new prefab.
                    rootObjectToSave = bbRendererGO;
                }

                if (rootObjectToSave != null)
                {
                    // Apply the original prefab's rotation to the new root object.
                    rootObjectToSave.transform.rotation = sourcePrefabRotation;

                    // Apply scale differently depending on whether an LOD group was created.
                    if (activeSettings.EnableLODCreation)
                    {
                        // The root (LOD Group) scale should match the original prefab's scale.
                        // The child renderer's scale is relative to this parent.
                        rootObjectToSave.transform.localScale = sourcePrefabScale;
                    }
                    else
                    {
                        // If no LOD group, the root IS the renderer. Its final scale is a combination
                        // of the source prefab's scale and our new XZ factor.
                        rootObjectToSave.transform.localScale = Vector3.Scale(rootObjectToSave.transform.localScale, sourcePrefabScale);
                    }

                    // Apply the manual vertical offset.
                    if (activeSettings.EnableLODCreation)
                    {
                        // The offset is already on the child renderer, so the parent root stays at the origin.
                        rootObjectToSave.transform.position = Vector3.zero;
                    }
                    else
                    {
                        // No parent, so apply the offset directly to the root object itself.
                        rootObjectToSave.transform.position = new Vector3(0, activeSettings.ManualVerticalOffset, 0);
                    }

                    // --- 7. SAVE FINAL PREFAB AND CLEANUP ---
                    string finalPrefabPath = AssetDatabase.GenerateUniqueAssetPath(Path.Combine(targetDirectoryPath, rootObjectToSave.name + ".prefab"));
                    bool success;
                    PrefabUtility.SaveAsPrefabAsset(rootObjectToSave, finalPrefabPath, out success);
                    // Clean up the temporary GameObject from the scene now that it's saved as a prefab.
                    DestroyImmediate(rootObjectToSave);

                    if (success)
                    {
                        AssetDatabase.SaveAssets();
                        AssetDatabase.Refresh();
                        EditorUtility.DisplayDialog("Success", $"Billboard assets created in:\n{targetDirectoryPath}", "OK");
                        // Select the newly created prefab in the project window for user convenience.
                        Selection.activeObject = AssetDatabase.LoadAssetAtPath<GameObject>(finalPrefabPath);

                        // --- NEW: Destroy Source Scene Object Logic ---
                        // Check if the user opted to destroy the source object after a successful creation.
                        if (activeSettings.DestroySourceSceneObject && sourcePrefab != null)
                        {
                            // IMPORTANT SAFETY CHECK: Only destroy if the source is a scene object.
                            // This prevents accidental deletion of project prefab assets.
                            if (PrefabUtility.GetPrefabAssetType(sourcePrefab) == PrefabAssetType.NotAPrefab)
                            {
                                // Safely destroy the original GameObject from the scene.
                                DestroyImmediate(sourcePrefab);
                                sourcePrefab = null; // Clear the reference in the editor window.
                                Debug.Log("Source scene object has been destroyed as requested.");
                            }
                        }
                    }
                    else
                    {
                        throw new Exception("Failed to save the final prefab asset.");
                    }
                }
            }
            catch (Exception e)
            {
                // --- 8. ERROR HANDLING AND CLEANUP ---
                // If any part of the process fails, log the error and attempt to clean up any
                // partially created assets to avoid cluttering the project.
                Debug.LogError($"Asset creation error: {e.Message}\n{e.StackTrace}");
                if (!string.IsNullOrEmpty(meshPathVal) && File.Exists(Path.GetFullPath(meshPathVal))) AssetDatabase.DeleteAsset(meshPathVal);
                if (!string.IsNullOrEmpty(matPath) && File.Exists(Path.GetFullPath(matPath))) AssetDatabase.DeleteAsset(matPath);
                if (!string.IsNullOrEmpty(albPath) && File.Exists(Path.GetFullPath(albPath))) AssetDatabase.DeleteAsset(albPath);
                if (!string.IsNullOrEmpty(nrmPath) && File.Exists(Path.GetFullPath(nrmPath))) AssetDatabase.DeleteAsset(nrmPath);
                AssetDatabase.Refresh();
                EditorUtility.DisplayDialog("Error", "Asset creation failed. Check the console for more details.", "OK");
            }
        }

        /// <summary>
        /// Renders the entire user interface for the Billboard Creator window.
        /// This method is called repeatedly by OnGUI and is responsible for drawing all controls,
        /// labels, and previews, and for linking them to the 'activeSettings' ScriptableObject.
        /// </summary>
        private void DrawFullUI()
        {
            // =================================================================================
            // CORE SETUP
            // This section contains the most fundamental settings: the object to be converted
            // and the primary parameters that define the billboard's structure and quality.
            // =================================================================================
            GUILayout.Label("Core Setup", EditorStyles.boldLabel);

            // Field for the user to assign the GameObject to be converted into a billboard.
            sourcePrefab = (GameObject)EditorGUILayout.ObjectField("Source Prefab", sourcePrefab, typeof(GameObject), false);

            // --- Unconditional BillboardAnchor Reminder ---
            // This note is always visible to constantly remind the user of this important best practice.
            EditorGUILayout.HelpBox("Reminder: For the most accurate pivot point, add an empty child GameObject named exactly 'BillboardAnchor' to your source object at its desired X/Z center.", MessageType.Info);

            // --- BillboardAnchor Reminder ---
            if (sourcePrefab != null)
            {
                if (sourcePrefab.transform.Find("BillboardAnchor") == null)
                {
                    // This note is critical for good results and is placed prominently at the top.
                    EditorGUILayout.HelpBox("Reminder: For the most accurate pivot point, add an empty child GameObject named exactly 'BillboardAnchor' to your source object at its desired X/Z center.", MessageType.Warning);
                }
            }

            // Field to specify which Level of Detail (LOD) from the source object should be used for the capture.
            activeSettings.SourceLODIndex = EditorGUILayout.IntField(new GUIContent("Source LOD Index", "The LOD level of the source prefab to use for generating the billboard. LOD 0 is the highest quality."), activeSettings.SourceLODIndex);
            if (activeSettings.SourceLODIndex < 0) activeSettings.SourceLODIndex = 0;

            // A dropdown to select the number of radial views (e.g., front, side, back).
            activeSettings.NumSnapshotsIndex = EditorGUILayout.Popup(new GUIContent("Number of Snapshots (Radial)", "The number of different angles the billboard will be captured from for its vertical planes."), activeSettings.NumSnapshotsIndex, numSnapshotsDisplayOptions);

            // --- Guidance on LOD and Snapshot Count ---
            EditorGUILayout.HelpBox("Tip: For the smoothest LOD transition, it's use a higher # LOD as the source (if you have one). Most objects look best with 3 quads, but conifers often benefit from 4 or more.", MessageType.Info);

            // A critical choice between performance and visual fidelity for the final mesh and material.
            activeSettings.RenderMode = (BillboardRenderMode)EditorGUILayout.EnumPopup(new GUIContent("Render Mode", "The core strategy for mesh and texture generation."), activeSettings.RenderMode);
            EditorGUILayout.HelpBox("• Efficient: Uses single planes with a double-sided shader. Most performant.\n\n• HighQuality: Creates separate front and back planes for better lighting fidelity, at the cost of more triangles.", MessageType.Info);
            EditorGUILayout.Space();

            // =================================================================================
            // CAPTURE SETTINGS
            // This section controls the virtual camera and environment during the texture snapshot process.
            // =================================================================================
            GUILayout.Label("Capture Settings", EditorStyles.boldLabel);
            activeSettings.CameraCaptureDistanceOffset = EditorGUILayout.FloatField(new GUIContent("Cam Distance Offset", "How far the camera is positioned from the object's bounding box. Increase this if parts of your model are being cut off in the texture."), activeSettings.CameraCaptureDistanceOffset);
            activeSettings.FramePadding = EditorGUILayout.Slider(new GUIContent("Frame Padding", "Adds empty space around the object in the texture frame. This helps prevent UV filtering artifacts where the texture edge might wrap or clamp incorrectly."), activeSettings.FramePadding, 0f, 0.3f);
            activeSettings.SnapshotLayerIndex = EditorGUILayout.LayerField(new GUIContent("Snapshot Layer", "Select a dedicated, unused layer. The object is temporarily moved to this layer during capture to isolate it from the rest of the scene."), activeSettings.SnapshotLayerIndex);

            // --- Guidance on Snapshot Layer ---
            EditorGUILayout.HelpBox("Important: To prevent other objects from appearing in your billboard texture, always use a scene layer that is otherwise empty and unused.", MessageType.Info);

            activeSettings.GenerateNormalMap = EditorGUILayout.Toggle(new GUIContent("Generate Normal Map", "Creates a normal map for the billboard, allowing it to react to dynamic lighting and appear to have surface detail."), activeSettings.GenerateNormalMap);
            EditorGUILayout.Space();

            // =================================================================================
            // HORIZONTAL QUADS (OPTIONAL)
            // =================================================================================
            showHorizontalSectionsUI = EditorGUILayout.Foldout(showHorizontalSectionsUI, "Horizontal Cross-Section Quads (Optional)", true, EditorStyles.foldoutHeader);
            if (showHorizontalSectionsUI)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.HelpBox("Define optional horizontal planes that use a top-down snapshot. These do not always improve trees, but can be useful for some objects, and are good for top down views.", MessageType.Info);
                if (activeSettings.HorizontalCrossSectionDefs == null) activeSettings.HorizontalCrossSectionDefs = new List<HorizontalCrossSectionDefinition>();
                for (int i = 0; i < activeSettings.HorizontalCrossSectionDefs.Count; i++)
                {
                    EditorGUILayout.LabelField($"Quad Section {i + 1}", EditorStyles.boldLabel);
                    HorizontalCrossSectionDefinition currentDef = activeSettings.HorizontalCrossSectionDefs[i];
                    currentDef.heightFraction = EditorGUILayout.Slider("Height Fraction", currentDef.heightFraction, 0f, 1f);
                    currentDef.sizeMultiplier = EditorGUILayout.Slider("Size Multiplier", currentDef.sizeMultiplier, 0f, 1f);
                    currentDef.rotationDegrees = EditorGUILayout.Slider("Y-Rotation (Degrees)", currentDef.rotationDegrees, 0f, 360f);
                    activeSettings.HorizontalCrossSectionDefs[i] = currentDef;
                    if (GUILayout.Button("- Remove Section " + (i + 1), GUILayout.Width(150))) { activeSettings.HorizontalCrossSectionDefs.RemoveAt(i); GUI.FocusControl(null); i--; }
                    EditorGUILayout.Space(5);
                }
                if (GUILayout.Button("Add Horizontal Quad Section", GUILayout.Height(25))) { activeSettings.HorizontalCrossSectionDefs.Add(new HorizontalCrossSectionDefinition(activeSettings.HorizontalCrossSectionDefs.Count > 0 ? Mathf.Clamp01(activeSettings.HorizontalCrossSectionDefs.Last().heightFraction + 0.1f) : 0.5f, 0.5f, 0f)); }
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.Space();

            // =================================================================================
            // TEXTURE PROCESSING & MATERIAL
            // =================================================================================
            GUILayout.Label("Texture Processing & Material", EditorStyles.boldLabel);
            activeSettings.MaterialSmoothness = EditorGUILayout.Slider(new GUIContent("Material Smoothness", "Controls the glossiness of the final material."), activeSettings.MaterialSmoothness, 0.0f, 1.0f);
            activeSettings.AlphaProcessingClipThreshold = EditorGUILayout.Slider(new GUIContent("Alpha Clip Threshold (Bake)", "During texture generation, any pixel with an alpha value below this will be made fully transparent. This is a pre-processing step to clean the source texture."), activeSettings.AlphaProcessingClipThreshold, 0.01f, 0.99f);
            activeSettings.MaterialAlphaClipThreshold = EditorGUILayout.Slider(new GUIContent("Material Alpha Clip (Final)", "Sets the '_Cutoff' property on the final material, controlling how transparent pixels are rendered in-game by the shader."), activeSettings.MaterialAlphaClipThreshold, 0.0f, 1.0f);

            // --- Guidance on Quality Settings ---
            EditorGUILayout.HelpBox("The settings below are for quality enhancement and artifact fixing. Supersampling reduces jagged edges, while Edge Padding prevents transparent halos. They can be left on their default values for most cases.", MessageType.Info);

            activeSettings.SupersamplingIndex = EditorGUILayout.Popup(new GUIContent("Supersampling Factor", "Renders snapshots at a higher resolution before downscaling to the final size. Reduces jagged edges (aliasing) at the cost of longer generation time."), activeSettings.SupersamplingIndex, supersamplingOptions);
            activeSettings.EnableEdgePadding = EditorGUILayout.Toggle(new GUIContent("Enable Edge Padding", "Extends pixel colors into transparent areas to prevent dark halos or seams when textures are mipmapped or filtered."), activeSettings.EnableEdgePadding);
            if (activeSettings.EnableEdgePadding) { EditorGUI.indentLevel++; activeSettings.EdgePaddingIterations = EditorGUILayout.IntSlider("Padding Iterations", activeSettings.EdgePaddingIterations, 1, 10); EditorGUI.indentLevel--; }
            EditorGUILayout.Space();

            // =================================================================================
            // BILLBOARD SHAPE & SIZE
            // =================================================================================
            GUILayout.Label("Billboard Shape & Size", EditorStyles.boldLabel);
            activeSettings.XZScaleFactor = EditorGUILayout.Slider(new GUIContent("XZ Scale Factor", "Widens the billboard to make it appear fuller."), activeSettings.XZScaleFactor, 1.0f, 2.0f);
            activeSettings.ManualVerticalOffset = EditorGUILayout.FloatField(new GUIContent("Manual Vertical Offset", "A final height adjustment (in meters) applied to the generated prefab. Use this to correct floating or sinking billboards if the automatic pivot calculation isn't perfect."), activeSettings.ManualVerticalOffset);

            // --- Guidance on Sizing ---
            EditorGUILayout.HelpBox("Tip: An XZ Scale Factor between 1.0 and 1.2 is often best to make the billboard feel less flat. A Manual Vertical Offset between 0.0 and -0.4 is sometimes needed to align the billboard's base with the ground, as the object's pivot may not be at its lowest point.", MessageType.Info);

            activeSettings.ProfileShape = (BillboardProfile)EditorGUILayout.EnumPopup("Profile Shape", activeSettings.ProfileShape);
            if (activeSettings.ProfileShape == BillboardProfile.Octagon)
            {
                EditorGUI.indentLevel++;
                activeSettings.OctagonBottomWidthFraction = EditorGUILayout.Slider("Bottom Width Fraction", activeSettings.OctagonBottomWidthFraction, 0.01f, 1.0f);
                activeSettings.OctagonTopWidthFraction = EditorGUILayout.Slider("Top Width Fraction", activeSettings.OctagonTopWidthFraction, 0.01f, 1.0f);
                activeSettings.OctagonMaxWidthCenterYFraction = EditorGUILayout.Slider("Max Width Center Y (%)", activeSettings.OctagonMaxWidthCenterYFraction * 100f, OCTAGON_SHOULDER_VERTICAL_FRACTION_CONST * 50f, 100f - (OCTAGON_SHOULDER_VERTICAL_FRACTION_CONST * 50f)) / 100f;
                EditorGUILayout.HelpBox($"Shoulder vertical extent: {OCTAGON_SHOULDER_VERTICAL_FRACTION_CONST * 100:F0}% of height.", MessageType.None);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.Space();

            // =================================================================================
            // SNAPSHOT LIGHTING
            // =================================================================================
            GUILayout.Label("Snapshot Lighting Settings", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("These settings create a temporary, controlled lighting environment to ensure consistent captures regardless of your current scene's lighting. Try these at 1,1,1 at first then change them if the imposter needs to be darker or lighter.  ", MessageType.Info);
            activeSettings.SnapshotAmbientLightMultiplier = EditorGUILayout.Slider("Ambient Multiplier", activeSettings.SnapshotAmbientLightMultiplier, 0f, 3f);
            activeSettings.SnapshotAmbientIntensity = EditorGUILayout.Slider("Ambient Intensity", activeSettings.SnapshotAmbientIntensity, 0f, 3f);
            activeSettings.SnapshotKeyLightIntensity = EditorGUILayout.Slider("Key Light Intensity", activeSettings.SnapshotKeyLightIntensity, 0f, 5f);
            activeSettings.SnapshotKeyLightRotation = EditorGUILayout.Vector3Field("Key Light Euler Rotation", activeSettings.SnapshotKeyLightRotation);
            EditorGUILayout.Space();

            // =================================================================================
            // OUTPUT & LOD
            // =================================================================================
            GUILayout.Label("Output & LOD Settings", EditorStyles.boldLabel);
            activeSettings.UserDefinedBaseName = EditorGUILayout.TextField("Output File Prefix", activeSettings.UserDefinedBaseName);
            activeSettings.EnableLODCreation = EditorGUILayout.Toggle(new GUIContent("Create/Update LOD Group", "If enabled, a new LOD containing the billboard will be added to the source prefab's LODGroup. If the source has no LODGroup, a new one will be created."), activeSettings.EnableLODCreation);
            if (activeSettings.EnableLODCreation)
            {
                EditorGUI.indentLevel++;
                activeSettings.CullCutoffPercent = EditorGUILayout.Slider(new GUIContent("Cull Below Screen %", "Object is culled (disappears) when its screen height is below this percentage."), activeSettings.CullCutoffPercent, 0.1f, 20.0f);
                float minBillboardTransition = activeSettings.CullCutoffPercent + 0.1f;
                activeSettings.BillboardLODTransitionPercent = EditorGUILayout.Slider(new GUIContent("Billboard Transition Screen %", "The billboard LOD becomes visible when screen height is at or below this percentage."), activeSettings.BillboardLODTransitionPercent, minBillboardTransition, 99.0f);
                EditorGUILayout.HelpBox("LODs transition based on the object's height relative to the screen.  If the object has an exisiting LOD group, it will insert the imposter and readjust the cull % based on this.", MessageType.Info);
                EditorGUI.indentLevel--;
            }
            activeSettings.DestroySourceSceneObject = EditorGUILayout.Toggle(new GUIContent("Destroy Source Scene Object", "If the source is an object in the scene (not a project prefab), it will be destroyed after the billboard is created. This does NOT delete project assets."), activeSettings.DestroySourceSceneObject);
            if (activeSettings.DestroySourceSceneObject)
            {
                EditorGUILayout.HelpBox("This will remove the original object from your scene upon successful billboard creation. The original prefab in your project files will NOT be affected.", MessageType.Info);
            }
            EditorGUILayout.Space();

            // =================================================================================
            // ACTION BUTTONS & PREVIEWS
            // =================================================================================
            Shader activeNormalShader = GetActiveNormalCaptureShader();
            bool canGenerateTextures = sourcePrefab != null && activeSettings != null && (activeNormalShader != null || !activeSettings.GenerateNormalMap);
            GUI.enabled = canGenerateTextures;
            // This button now includes a conditional confirmation dialog.
            if (GUILayout.Button("1. Generate Snapshot Atlas Data", GUILayout.Height(30)))
            {
                // Check if the source prefab has been assigned but is missing the anchor.
                bool anchorIsMissing = (sourcePrefab != null && sourcePrefab.transform.Find("BillboardAnchor") == null);

                if (anchorIsMissing)
                {
                    // If the anchor is missing, show a confirmation dialog.
                    if (EditorUtility.DisplayDialog("Missing BillboardAnchor",
                        "The source object does not have a 'BillboardAnchor' child. This is highly recommended for accurate pivot placement.\n\nAre you sure you want to proceed without it?",
                        "Yes, Proceed", "No, Cancel"))
                    {
                        // If the user clicks "Yes", proceed with generation.
                        GenerateSnapshotData();
                    }
                    // If they click "No", do nothing.
                }
                else
                {
                    // If the anchor exists (or no prefab is assigned yet), call the generation method directly.
                    GenerateSnapshotData();
                }
            }
            if (!canGenerateTextures && activeSettings != null && activeSettings.GenerateNormalMap && activeNormalShader == null) { EditorGUILayout.HelpBox("A 'Normal Capture' shader for the current render pipeline could not be found. Please ensure the correct shader package is installed.", MessageType.Error); }
            if (lastGeneratedSnapshotData?.AlbedoAtlasTexture != null)
            {
                string previewLabel = $"Snapshot Atlas Previews ({lastGeneratedSnapshotData.Views} radial dirs";
                if (lastGeneratedSnapshotData.ViewFromDirections.Count > lastGeneratedSnapshotData.Views) previewLabel += " + Top-Down Ortho";
                previewLabel += "):";
                GUILayout.Label(previewLabel, EditorStyles.centeredGreyMiniLabel);
                EditorGUILayout.BeginHorizontal();
                DisplayAtlasPreview("Albedo Atlas", lastGeneratedSnapshotData.AlbedoAtlasTexture);
                if (lastGeneratedSnapshotData.NormalAtlasTexture != null && activeSettings.GenerateNormalMap) { DisplayAtlasPreview("Normal Atlas", lastGeneratedSnapshotData.NormalAtlasTexture); }
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.Space();
                bool canCreateBB = sourcePrefab != null && lastGeneratedSnapshotData.SourceObjectViewWidths?.Count >= lastGeneratedSnapshotData.Views && lastSourceObjectNormalizedBounds.size != Vector3.zero;
                GUI.enabled = canCreateBB;
                string confirmBtnTxt = $"2. Create {lastGeneratedSnapshotData.Views}-Dir {activeSettings.ProfileShape} Billboard ({activeSettings.RenderMode})";
                if (activeSettings.EnableLODCreation) confirmBtnTxt += " (with LODs)";
                if (GUILayout.Button(confirmBtnTxt, GUILayout.Height(30))) { CreateBillboardAssetsFromGeneratedData(); }
                GUI.enabled = true;
            }
            else { EditorGUILayout.HelpBox("Generate Snapshot Atlas Data first. Previews and the 'Create Billboard Assets' button will appear after.", MessageType.Info); }
            GUI.enabled = !string.IsNullOrEmpty(lastGeneratedAssetPath) && AssetDatabase.IsValidFolder(lastGeneratedAssetPath);
            if (GUILayout.Button("Delete Last Generated Assets")) { DeleteLastGeneratedAssets(); }
            GUI.enabled = true;
        }

        // --- HELPER METHODS ---

        /// <summary>
        /// Applies the user-defined material properties from the settings asset to the newly created material.
        /// This includes setting alpha clipping, smoothness, and the appropriate culling mode based on the selected RenderMode.
        /// </summary>
        /// <param name="mat">The Material to be configured.</param>
        /// <summary>
        /// Applies the user-defined material properties from the settings asset to the newly created material.
        /// This includes setting alpha clipping, smoothness, and the appropriate culling mode based on the selected RenderMode.
        /// It handles the specific property differences between the Built-in, URP, and HDRP shaders.
        /// </summary>
        /// <param name="mat">The Material to be configured.</param>
        private void SetMaterialProperties(Material mat)
        {
            RenderPipelineType pipeline = GetActivePipeline();

            // --- PBR & Alpha Settings (Pipeline-Specific) ---
            if (pipeline == RenderPipelineType.BuiltIn)
            {
                // For the Standard Shader, we need to configure it for "Cutout" rendering mode.
                mat.SetFloat("_Mode", 1); // 1 corresponds to the "Cutout" rendermode in the Standard shader.
                mat.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                mat.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero);
                mat.SetInt("_ZWrite", 1);
                mat.EnableKeyword("_ALPHATEST_ON");
                mat.renderQueue = (int)UnityEngine.Rendering.RenderQueue.AlphaTest;

                // Apply the user-defined alpha cutoff and smoothness.
                mat.SetFloat("_Cutoff", activeSettings.MaterialAlphaClipThreshold);
                mat.SetFloat("_Glossiness", activeSettings.MaterialSmoothness); // The Standard shader uses "_Glossiness" for smoothness.
                mat.SetFloat("_Metallic", 0f); // Billboards are typically non-metallic.
            }
            else // URP & HDRP
            {
                // For scriptable pipelines (URP/HDRP), we enable alpha clipping via a specific property.
                if (mat.HasProperty("_AlphaClip")) mat.SetFloat("_AlphaClip", 1f);
                if (mat.HasProperty("_Cutoff")) mat.SetFloat("_Cutoff", activeSettings.MaterialAlphaClipThreshold);

                // URP and HDRP Lit shaders use "_Smoothness".
                if (mat.HasProperty("_Smoothness")) mat.SetFloat("_Smoothness", activeSettings.MaterialSmoothness);
                if (mat.HasProperty("_Metallic")) mat.SetFloat("_Metallic", 0f);

                // Ensure the surface type is set to Opaque, as this is the correct mode for alpha-clipped materials.
                if (mat.HasProperty("_Surface")) mat.SetFloat("_Surface", 0f); // URP: 0 = Opaque
                if (mat.HasProperty("_SurfaceType")) mat.SetFloat("_SurfaceType", 0f); // HDRP: 0 = Opaque
            }


            // --- Culling Mode (Universal for all pipelines) ---
            // This determines which sides of the mesh polygons are rendered.
            if (activeSettings.RenderMode == BillboardRenderMode.Efficient)
            {
                // For 'Efficient' mode, we use a single plane and need it to be visible from both front and back.
                // We achieve this by turning culling off, which tells the GPU to render both sides.
                if (mat.HasProperty("_Cull")) mat.SetFloat("_Cull", (float)CullMode.Off);
                if (mat.HasProperty("_DoubleSidedEnable")) mat.SetFloat("_DoubleSidedEnable", 1.0f); // Specific property for HDRP double-sided.
            }
            else // HighQuality
            {
                // For 'HighQuality' mode, we have already generated proper back-facing geometry in the mesh service.
                // Therefore, we can use standard back-face culling, which is slightly more performant.
                if (mat.HasProperty("_Cull")) mat.SetFloat("_Cull", (float)CullMode.Back);
            }
        }


        /// <summary>
        /// Constructs a new prefab that contains an LODGroup. It takes the original object and the newly created
        /// billboard renderer, combines them under a new root, and configures the LODGroup component to transition
        /// between them based on screen size.
        /// </summary>
        /// <param name="billboardRendererGO">The newly created GameObject that holds the billboard mesh and material.</param>
        /// <param name="baseName">The base name for the new root GameObject.</param>
        /// <returns>The root GameObject of the new LOD prefab structure.</returns>
        private GameObject CreateLODPrefab(GameObject billboardRendererGO, string baseName)
        {
            // This is the root of the new prefab we are creating.
            GameObject rootLODGO = new GameObject(baseName);

            // Instantiate the user's original prefab as a child of our new root.
            // This preserves the original high-detail model.
            GameObject origInst = null;
            if (PrefabUtility.IsPartOfPrefabAsset(sourcePrefab))
                origInst = (GameObject)PrefabUtility.InstantiatePrefab(sourcePrefab, rootLODGO.transform);
            else
                origInst = Instantiate(sourcePrefab, rootLODGO.transform);

            origInst.name = sourcePrefab.name;
            // Reset the local transform of the original instance, as its world transform will be controlled by the new root.
            origInst.transform.SetPositionAndRotation(Vector3.zero, Quaternion.identity);
            origInst.transform.localScale = Vector3.one;

            // Parent the new billboard renderer object under the root as well.
            billboardRendererGO.transform.SetParent(rootLODGO.transform, false);

            // Add the LODGroup component to the root object. This will manage the switching.
            LODGroup newLODGrp = rootLODGO.AddComponent<LODGroup>();

            var newLods = new List<LOD>();

            // Check if the INSTANTIATED original prefab already has an LODGroup.
            LODGroup sourceLODGroup = origInst.GetComponent<LODGroup>();

            // Convert the user-facing percentage values to the 0-1 range used by the LODGroup component.
            float billboardTransition = activeSettings.BillboardLODTransitionPercent / 100.0f;
            float cullTransition = activeSettings.CullCutoffPercent / 100.0f;

            if (sourceLODGroup != null)
            {
                // If the original has an LODGroup, we copy its LOD levels and re-space them to make room for our new billboard LOD.
                int numSourceLods = sourceLODGroup.lodCount;
                LOD[] existingLODs = sourceLODGroup.GetLODs();

                // The existing LODs will now occupy the space between 100% and the billboard transition percentage.
                float availableRange = 1.0f - billboardTransition;
                for (int i = 0; i < numSourceLods; i++)
                {
                    // Scale the original transition height into the new available range.
                    float newTransitionHeight = billboardTransition + (existingLODs[i].screenRelativeTransitionHeight * availableRange);
                    newLods.Add(new LOD(newTransitionHeight, existingLODs[i].renderers));
                }

                // IMPORTANT: We must destroy the LODGroup on the child object. Nested LODGroups are not supported and cause issues.
                // The new single LODGroup on the root will control everything.
                DestroyImmediate(sourceLODGroup);
            }
            else
            {
                // If the original prefab does NOT have an LOD group, we treat all its renderers as a single group for LOD0.
                Renderer[] originalRenderers = origInst.GetComponentsInChildren<Renderer>(true).Where(r => r != null && r.enabled).ToArray();
                if (originalRenderers.Length > 0)
                {
                    // This LOD will be active from 100% screen height down to the billboard transition point.
                    newLods.Add(new LOD(billboardTransition, originalRenderers));
                }
            }

            // Now, add our new billboard as the final LOD level before culling.
            Renderer[] billboardRenderers = billboardRendererGO.GetComponentsInChildren<Renderer>(true).Where(r => r != null && r.enabled).ToArray();
            if (billboardRenderers.Length > 0)
            {
                // This LOD is active from the billboard transition point down to the culling point.
                newLods.Add(new LOD(cullTransition, billboardRenderers));
            }

            // Apply the newly constructed list of LODs to the root group and recalculate its bounds.
            newLODGrp.SetLODs(newLods.ToArray());
            newLODGrp.RecalculateBounds();

            return rootLODGO;
        }

        /// <summary>
        /// Determines the correct shader name and material property names based on the currently active render pipeline.
        /// This allows the tool to work seamlessly with the Built-in, URP, and HDRP pipelines.
        /// </summary>
        /// <returns>A tuple containing the shader name, albedo property name, normal property name, and normal map shader keyword.</returns>
        private (string shaderName, string albedoProperty, string normalProperty, string normalKeyword) GetPipelineMaterialInfo()
        {
            RenderPipelineType pipeline = GetActivePipeline();

            switch (pipeline)
            {
                case RenderPipelineType.URP:
                    return ("Universal Render Pipeline/Lit", "_BaseMap", "_BumpMap", "_NORMALMAP");

                case RenderPipelineType.HDRP:
                    return ("HDRP/Lit", "_BaseColorMap", "_NormalMap", "_NORMALMAP");

                case RenderPipelineType.BuiltIn:
                default: // Fallback to Built-in
                    return ("Standard", "_MainTex", "_BumpMap", "_NORMALMAP");
            }
        }

        /// <summary>
        /// Draws a texture preview in the editor window's GUI, scaling it to fit the available space.
        /// </summary>
        /// <param name="label">The label to display above the texture preview.</param>
        /// <param name="texture">The Texture2D to display.</param>
        private void DisplayAtlasPreview(string label, Texture2D texture)
        {
            if (texture == null) return;
            EditorGUILayout.BeginVertical(GUILayout.MaxWidth(position.width / 2f - 15f), GUILayout.ExpandHeight(false));
            GUILayout.Label(label, EditorStyles.centeredGreyMiniLabel);

            // Calculate the correct aspect ratio and size for the preview box.
            float previewAspect = (float)texture.width / Mathf.Max(1f, texture.height);
            float availableWidth = Mathf.Max(50f, position.width / 2f - 25f);
            float previewHeight = Mathf.Clamp(availableWidth / Mathf.Max(0.01f, previewAspect), 50f, 200f);
            float previewWidth = previewHeight * previewAspect;
            if (previewWidth > availableWidth) { previewWidth = availableWidth; previewHeight = previewWidth / Mathf.Max(0.01f, previewAspect); }

            // Get a rectangle from the layout system and draw the texture into it.
            Rect previewRect = GUILayoutUtility.GetRect(previewWidth, previewHeight, GUILayout.ExpandWidth(false), GUILayout.ExpandHeight(false));
            EditorGUI.DrawPreviewTexture(previewRect, texture, null, ScaleMode.ScaleToFit);
            EditorGUILayout.EndVertical();
        }

        /// <summary>
        /// A robust method to calculate the total bounding box of a GameObject.
        /// It prioritizes MeshRenderers and SkinnedMeshRenderers, but will fall back to using Colliders
        /// if no renderers are found. This is crucial for correctly framing the object during snapshots.
        /// </summary>
        /// <param name="go">The GameObject to measure.</param>
        /// <returns>A Bounds object representing the combined volume of all renderers or colliders.</returns>
        private Bounds CalculateObjectBounds(GameObject go)
        {
            Renderer[] renderers = go.GetComponentsInChildren<Renderer>(true);
            if (renderers.Length == 0)
            {
                // Fallback to colliders if no renderers are found.
                Collider[] colliders = go.GetComponentsInChildren<Collider>(true);
                if (colliders.Length > 0)
                {
                    Bounds cB = colliders[0].bounds;
                    for (int i = 1; i < colliders.Length; i++) if (colliders[i].enabled) cB.Encapsulate(colliders[i].bounds);
                    if (cB.size == Vector3.zero) cB.size = Vector3.one * 0.01f; // Prevent zero-sized bounds.
                    return cB;
                }
                // If no renderers or colliders, return a small default bound at the object's position.
                return new Bounds(go.transform.position, Vector3.one * 0.1f);
            }
            else
            {
                Bounds b = new Bounds();
                bool first = true;
                foreach (Renderer r in renderers)
                {
                    if (r.enabled)
                    {
                        Bounds rB = r.bounds;
                        // Special handling for SkinnedMeshRenderers which might have zero bounds when not animated.
                        // We use the bounds from the mesh asset itself in this case.
                        if (rB.size == Vector3.zero && r is SkinnedMeshRenderer smr && smr.sharedMesh != null)
                        {
                            rB = smr.sharedMesh.bounds;
                            rB.center = smr.transform.TransformPoint(rB.center); // Transform center to world space.
                        }
                        if (rB.size != Vector3.zero)
                        {
                            if (!first) { b.Encapsulate(rB); }
                            else { b = rB; first = false; }
                        }
                    }
                }
                if (first) return new Bounds(go.transform.position, Vector3.one * 0.1f);
                if (b.size == Vector3.zero) b.size = Vector3.one * 0.01f;
                return b;
            }
        }

        /// <summary>
        /// Finds and returns the correct normal capture shader for the currently active render pipeline.
        /// </summary>
        /// <returns>The appropriate Shader object, or null if not found.</returns>
        private Shader GetActiveNormalCaptureShader()
        {
            switch (GetActivePipeline())
            {
                case RenderPipelineType.BuiltIn:
                    return normalCaptureShaderBuiltIn; // Already cached
                case RenderPipelineType.URP:
                    return normalCaptureShaderURP; // Already cached
                case RenderPipelineType.HDRP:
                    return normalCaptureShaderHDRP; // Already cached
                default:
                    Debug.LogError("Unknown or unsupported render pipeline. Cannot find a normal capture shader.");
                    return null;
            }
        }

        /// <summary>
        /// Creates a new BillboardSettings ScriptableObject asset in the project.
        /// It opens a "Save File" dialog to let the user choose a location and name.
        /// </summary>
        private void CreateNewSettingsAsset()
        {
            string path = EditorUtility.SaveFilePanelInProject(
                "Save New Billboard Settings",
                "New Billboard Settings.asset",
                "asset",
                "Please enter a file name to save the settings to."
            );

            if (string.IsNullOrEmpty(path)) return; // User cancelled the dialog.

            BillboardSettings newSettings = CreateInstance<BillboardSettings>();
            AssetDatabase.CreateAsset(newSettings, path);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();

            // Automatically assign the newly created asset to the editor window.
            activeSettings = newSettings;
            EditorUtility.FocusProjectWindow();
            Selection.activeObject = newSettings;
        }

        /// <summary>
        /// Deletes the folder containing the assets from the most recent billboard generation.
        /// Asks the user for confirmation before deleting.
        /// </summary>
        private void DeleteLastGeneratedAssets()
        {
            if (string.IsNullOrEmpty(lastGeneratedAssetPath))
            {
                EditorUtility.DisplayDialog("Error", "No asset path recorded from the last generation.", "OK");
                return;
            }

            if (!AssetDatabase.IsValidFolder(lastGeneratedAssetPath))
            {
                EditorUtility.DisplayDialog("Error", $"The recorded path '{lastGeneratedAssetPath}' is no longer a valid folder.", "OK");
                lastGeneratedAssetPath = null;
                return;
            }

            if (EditorUtility.DisplayDialog("Delete Generated Assets?",
                $"Are you sure you want to delete the folder and all its contents?\n\n{lastGeneratedAssetPath}",
                "Yes, Delete", "No"))
            {
                if (AssetDatabase.DeleteAsset(lastGeneratedAssetPath))
                {
                    Debug.Log($"Successfully deleted folder: {lastGeneratedAssetPath}");
                    lastGeneratedAssetPath = null; // Clear the path after successful deletion.
                }
                else
                {
                    Debug.LogError($"Failed to delete folder: {lastGeneratedAssetPath}");
                }
            }
        }

        /// <summary>
        /// Prepares a temporary instance of the source object for snapshotting.
        /// It can normalize the transform and correctly handles forcing a specific LOD level to be visible.
        /// </summary>
        /// <param name="source">The source GameObject or prefab.</param>
        /// <param name="lodIndex">The LOD level to force active.</param>
        /// <param name="normalizeTransform">If true, the instance's transform will be reset to origin.</param>
        /// <returns>The prepared GameObject instance.</returns>
        public static GameObject PrepareInstanceForSnapshot(GameObject source, int lodIndex, bool normalizeTransform)
        {
            if (source == null) return null;

            // Instantiate the object, correctly handling both prefabs and scene objects.
            GameObject instance = PrefabUtility.IsPartOfPrefabAsset(source)
                ? (GameObject)PrefabUtility.InstantiatePrefab(source)
                : Instantiate(source);

            if (instance == null) return null;

            if (normalizeTransform)
            {
                // Reset the transform for a clean, axis-aligned capture.
                instance.transform.position = Vector3.zero;
                instance.transform.rotation = Quaternion.identity;
                instance.transform.localScale = Vector3.one;
            }

            LODGroup lodGroup = instance.GetComponentInChildren<LODGroup>(true);

            if (lodGroup != null)
            {
                // This is the robust way to handle LODs. Instead of manually enabling/disabling renderers,
                // we use Unity's built-in method to force a specific LOD level. This is safer and more reliable.
                lodGroup.enabled = true;
                lodGroup.ForceLOD(lodIndex);

                // In the editor, changes from ForceLOD might not apply immediately.
                // Queueing a player loop update helps ensure the visibility changes are processed
                // before we continue to the bounds calculation and snapshot steps.
                EditorApplication.QueuePlayerLoopUpdate();
            }

            return instance;
        }

        /// <summary>
        /// Detects and returns the currently active render pipeline in the project.
        /// </summary>
        /// <returns>An enum value representing the active pipeline.</returns>
        private RenderPipelineType GetActivePipeline()
        {
            if (GraphicsSettings.defaultRenderPipeline == null)
            {
                return RenderPipelineType.BuiltIn;
            }

            string pipelineName = GraphicsSettings.defaultRenderPipeline.GetType().Name;

            if (pipelineName.Contains("UniversalRenderPipelineAsset"))
            {
                return RenderPipelineType.URP;
            }
            else if (pipelineName.Contains("HDRenderPipelineAsset"))
            {
                return RenderPipelineType.HDRP;
            }

            return RenderPipelineType.Unknown;
        }

    }
}